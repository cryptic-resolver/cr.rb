#!/usr/bin/env ruby
# ------------------------------------------------------
# File          : cr.rb
# Authors       : ccmywish <ccmywish@qq.com>
# Created on    : <2021-07-08>
# Last modified : <2023-02-12>
#
# cr:
#
#   This file is used to explain a CRyptic command
# or an acronym's real meaning in computer world or
# other fields.
#
# ------------------------------------------------------

require 'cr'
require 'fileutils'


####################
# helper: for color
####################

def bold(str)       "\e[1m#{str}\e[0m" end
def underline(str)  "\e[4m#{str}\e[0m" end
def red(str)        "\e[31m#{str}\e[0m" end
def green(str)      "\e[32m#{str}\e[0m" end
def yellow(str)     "\e[33m#{str}\e[0m" end
def blue(str)       "\e[34m#{str}\e[0m" end
def purple(str)     "\e[35m#{str}\e[0m" end
def cyan(str)       "\e[36m#{str}\e[0m" end


####################
# core: logic
####################

def is_there_any_dict?
  unless Dir.exist? DEFAULT_LIB_PATH
    Dir.mkdir DEFAULT_LIB_PATH
  end

  !Dir.empty? DEFAULT_LIB_PATH
end


def add_default_dicts_if_none_exists
  unless is_there_any_dict?
    puts "cr: Adding default dicts..."

    begin
    if Gem.win_platform?
      # Windows doesn't have fork
      DEFAULT_DICTS_USER_AND_NAMES.each_with_index do |name, i|
        puts "cr: Pulling #{name}..."
        `git -C #{DEFAULT_LIB_PATH} clone #{CR_DEFAULT_DICTS[i]} -q`
      end
    else
      # *nix-like
      DEFAULT_DICTS_USER_AND_NAMES.each_with_index do |name, i|
        fork do
          puts "cr: Pulling #{name}..."
          `git -C #{DEFAULT_LIB_PATH} clone #{CR_DEFAULT_DICTS[i]} -q`
        end
      end
      Process.waitall
    end

    rescue Interrupt
      abort "cr: Cancel add default dicts"
    end

    puts "cr: Add done" ; word_count(p: false)
    puts ; puts "#{$DefaultLibWordCount} words added"

    # Really added
    return true
  end
  # Not added
  return false
end


# Notice that we only update the Default library, not Extra library
def update_dicts()
  return if add_default_dicts_if_none_exists

  word_count(p: false)
  old_wc = $DefaultLibWordCount

  puts "cr: Updating all dicts in Default library..."

  begin
  Dir.chdir DEFAULT_LIB_PATH do

    if RUBY_PLATFORM.include? "mingw"
      # Windows doesn't have fork
      Dir.children(DEFAULT_LIB_PATH).each do |dict|
        puts "cr: Wait to update #{dict}..."
        `git -C ./#{dict} pull -q`
      end
    else
      # *nix
      Dir.children(DEFAULT_LIB_PATH).each do |dict|
        fork do
          puts "cr: Wait to update #{dict}..."
         `git -C ./#{dict} pull -q`
        end
      end
      Process.waitall

    end # end if/else
  end

  rescue Interrupt
    puts "cr: Cancel update"
    exit 1
  end

  puts "cr: Update done"

  # clear
  $DefaultLibWordCount = 0
  # recount
  word_count(p: false)

  new_wc = $DefaultLibWordCount

  puts
  puts "#{new_wc - old_wc} words added in Default library"

end


def add_dict(repo)
  if repo.nil?
    puts bold(red("cr: Need an argument!"))
    exit -1
  end

  # Ensure the cr home dir exists
  FileUtils.mkdir_p(DEFAULT_LIB_PATH)

  # Simplify adding dictionary
  if !repo.start_with?("https://") and !repo.start_with?("git@")
    if repo.include?('/')
      repo = "https://github.com/#{repo}.git"
    else
      repo = "https://github.com/cryptic-resolver/cryptic_#{repo}.git"
    end
  end

  begin
    puts "cr: Adding new dictionary..."
    `git -C #{DEFAULT_LIB_PATH} clone #{repo} -q`
  rescue Interrupt
    puts "cr: Cancel add dict"
    exit 1
  end

  puts "cr: Add new dictionary done"

  # github/com/ccmywish/ruby_knowledge(.git)
  dict = repo.split('/')[-1].delete_suffix('.git')
  wc = count_dict_words(DEFAULT_LIB_PATH ,dict)
  puts
  puts "#{wc} words added"

end


def del_dict(repo)
  if repo.nil?
    puts bold(red("cr: Need an argument!"))
    exit -1
  end
  Dir.chdir DEFAULT_LIB_PATH do
    begin
      # Dir.rmdir repo        # Can't rm a filled dir
      # FileUtils.rmdir repo  # Can't rm a filled dir
      FileUtils.rm_rf repo
      puts "cr: Delete dictionary #{bold(green(repo))} done"
    rescue Exception => e
      puts bold(red("cr: #{e}"))
      list_dicts
    end
  end
end


def load_sheet(library, dict, sheet_name)
  file = library + "/#{dict}/#{sheet_name}.toml"

  if File.exist? file
    return Tomlrb.load_file file # gem 'tomlrb'
    # return TOML.load_file file # gem 'toml'
  else
    nil
  end
end


#
# Pretty print the info of the given word
#
# A info looks like this
#   emacs = {
#     name = "Emacs"
#     desc = "edit macros"
#     more = "a feature-rich editor"
#     see  = ["Vim"]
#   }
#
# @param info [Hash] the information of the given word (mapped to a keyword in TOML)
#
def pp_info(info)
  name = info['name'] || red("No name!")  # keyword `or` is invalid here in Ruby

  desc = info['desc']
  more = info['more']

  if desc
    puts "\n  #{name}: #{desc}"
    print "\n  ",more,"\n" if more
  else
    puts "\n  #{name}"
    print "\n  ",more,"\n" if more
  end

  if see_also = info['see']
    print "\n", purple("SEE ALSO ")
    if see_also.is_a?(Array)
      last_ndx = see_also.size - 1
      see_also.each_with_index do |x,i|
        if last_ndx == i
          print underline(x)  # Last word doesn't show space
        else
          print underline(x),' '
        end
      end
    else
      print underline(see_also)
    end
    puts
  end
  puts
end

# Print default cryptic_ dicts
def pp_dict(dict)
    puts green("From: #{dict}")
end


#
# Used for synonym jump
# Because we absolutely jump to a must-have word
# So we can directly lookup to it
#
# Notice that, we must jump to a specific word definition
# So in the toml file, you must specify the precise word.
# If it has multiple meanings, for example
#
#   [blah]
#   same = "xdg"  # this is wrong, because xdg has multiple
#                 # definitions, and all of them specify a
#                 # category
#
#   [blah]
#   same = "XDG downloader =>xdg.Download" # this is correct
#
#   [blah]
#   name = "BlaH" # You may want to display a better name first
#   same = "XDG downloader =>xdg.Download" # this is correct
#
#
def pp_same_info(library, dict, word, cache_content, same_key, own_name)

  # If it's a synonym for anther word,
  # we should lookup into this dict again, but maybe with a different file

  # file name
  x = word.chr.downcase

  #
  # dictionary maintainer must obey the rule for xxx.yyy word:
  #   xxx should be lower case
  #   yyy can be any case
  #
  # Because yyy should clearly explain the category info, IBM is better than ibm
  # Implementation should not be too simple if we want to stress the function we
  # expect.
  #
  # 'jump to' will output to user, so this is important not only inside our sheet.
  #
  #     same = "XDM downloader=>xdm.Download"
  #
  # We split 'same' key into two parts via spaceship symbol `=>`, first part will
  # output to user, the second part is for internal jump.
  #

  jump_to, same = same_key.split("=>")
  same =  jump_to if same.nil?

  unless own_name
    own_name = word
  end
  puts blue(bold(own_name)) + ' redirects to ' + blue(bold(jump_to))

  #
  # As '.' is used to delimit a word and a category, what if
  # we jump to a dotted word?
  #
  #   [eg]
  #   same = "e.g." # this must lead to a wrong resolution to
  #                 # word 'e', category 'g'
  #
  # All you need is to be like this:
  #
  #   [eg]
  #   same = "'e.g.'" # cr will notice the single quote
  #

  if same =~ /^'(.*)'$/
    same, category = $1, nil
  else
    same, category = same.split('.')
  end

  if same.chr == x
    # No need to load another dictionary if match
    sheet_content = cache_content
  else
    sheet_content = load_sheet(library, dict, same.chr.downcase)
  end

  if category.nil?
    info = sheet_content[same]
  else
    info = sheet_content[same][category]
  end

  if info.nil?
    puts red("WARN: Synonym jumps to the wrong place `#{same}`,
      Please consider fixing this in `#{x}.toml` of the dictionary `#{dict}`")
    # exit
    return false
  # double or more jumps
  elsif same_key = info['same']
    own_name = info['name']
    return pp_same_info(library, dict, same, cache_content, same_key, own_name)
  else
    pp_info(info)
    return true
  end
end



#
# Lookup the given word in a sheet (a toml file) and also print.
# The core idea is that:
#
# 1. if the word is `same` with another synonym, it will directly jump to
#   a word in this dictionary, but maybe a different sheet.
#
# 2. load the toml file and check the given word
#   2.1 with no category specifier
#       [abcd]
#   2.2 with category specifier
#       [abcd.tYPe]
#
def lookup(library, dict, file, word)
  sheet_content = load_sheet(library, dict, file)
  return false if sheet_content.nil?

  info = sheet_content[word]
  return false if info.nil?

  # Warn if the info is empty. For example:
  #   emacs = { }
  if info.size == 0
    puts red("WARN: Lack of everything of the given word
      Please consider fixing this in the dict `#{dict}`")
    exit
  end


  # Word with no category specifier
  # We call this meaning as type 1
  type_1_exist_flag = false

  # if already jump, don't check the word itself
  is_jump = false

  # synonym info print
  if same_key = info['same']
    own_name = info['name']
    pp_dict(dict)
    pp_same_info(library, dict, word, sheet_content, same_key, own_name)
    # It's also a type 1
    type_1_exist_flag = true
    is_jump = true
  end

  # normal info print
  # To developer:
  #   The word should at least has one of `desc` and `more`
  #   But when none exists, this may not be considered wrong,
  #   Because the type2 make the case too.
  #
  #   So, just ignore it, even if it's really a mistake(insignificant)
  #   by dictionary maintainers.
  #
  if !is_jump && (info.has_key?('desc') || info.has_key?('more'))
    pp_dict(dict)
    pp_info(info)
    type_1_exist_flag = true
  end

  # Meanings with category specifier
  # We call this meaning as type 2
  categories = info.keys - ["name", "desc", "more", "same", "see"]

  if !categories.empty?

    if type_1_exist_flag
      print  blue(bold("OR")),"\n"
    else
      pp_dict(dict)
    end

    categories.each do |meaning|
      info0 = sheet_content[word][meaning]
      if same_key = info0['same']
        own_name = info0['name']
        pp_same_info(library, dict, word, sheet_content, same_key, own_name)
      else
        pp_info(info0)
      end

      # last meaning doesn't show this separate line
      print  blue(bold("OR")),"\n" unless categories.last == meaning
    end
    return true
  elsif type_1_exist_flag
    return true
  else
    return false
  end
end


#
# The main procedure of `cr`
#
#   1. Search the default library first
#   2. Search the extra library if it does exist
#
# The `search` is done via the `lookup` function. It will print
# the info while finding. If `lookup` always return false then
# means lacking of this word in our dicts. So a welcomed
# contribution is printed on the screen.
#
def resolve_word(word)

  add_default_dicts_if_none_exists

  word = word.downcase # downcase! would lead to frozen error in Ruby 2.7.2
  # The index is the toml file we'll look into
  index = word.chr
  case index
  when '0'..'9'
    index = '0-9'
  end

  # cache lookup's results
  results = []

  # First consider the default library
  default = Dir.children(DEFAULT_LIB_PATH)
  default.each do |dict|
    results << lookup(DEFAULT_LIB_PATH,dict,index,word)
  end

  # Then is the extra library
  if EXTRA_LIB_PATH
    extra = Dir.children(EXTRA_LIB_PATH)
    extra.each do |dict|
      results << lookup(EXTRA_LIB_PATH,dict,index,word)
    end
  end

  unless results.include? true
    puts <<-NotFound
cr: Not found anything.

You could

  #{blue("case 1: Update all dicts")}

    #{yellow("$cr -u")}

  #{blue("case 2: List available official and feature dicts")}

    #{yellow("$cr -l")}

    #{yellow("$cr -a repo")} (Add a specific dict to default lib)

  #{blue("case 3: Contribute to theses dicts")}

    Visit: https://github.com/cryptic-resolver

NotFound

  else
    return
  end

end


#
# Delegate to `search_word_internal`
#
def search_word(pattern)
  found_or_not1 = false
  found_or_not2 = false

  found_or_not1 = search_word_internal(pattern, DEFAULT_LIB_PATH)
  if EXTRA_LIB_PATH
    found_or_not2 = search_word_internal(pattern, EXTRA_LIB_PATH)
  end

  if (found_or_not1 == false) && (found_or_not2 == false)
    puts red("cr: No words match with #{pattern.inspect}")
    puts
  end
end

#
# This `search_word_internal` routine is quite like `resolve_word`
# Notice:
#   We handle two cases
#
#   1. the 'pattern' is the regexp itself
#   2. the 'pattern' is like '/blah/'
#
#  The second is what Ruby and Perl users like to do, handle it!
#
def search_word_internal(pattern, library)

  if pattern.nil?
    puts bold(red("cr: Need an argument!"))
    exit -1
  end

  add_default_dicts_if_none_exists

  if pattern =~ /^\/(.*)\/$/
    regexp = %r[#$1]
  else
    regexp = %r[#{pattern}]
  end

  found_or_not = false

  #
  # Try to match every word in all dicts
  #
  Dir.children(library).each do |dict|
    sheets = Dir.children(File.join(library, dict)).select do
      _1.end_with?('.toml')
    end

    similar_words_in_a_dict = []

    sheets.each do |sheet|
      sheet_content = load_sheet(library, dict, File.basename(sheet,'.toml'))

      sheet_content.keys.each do
        if _1 =~ regexp
          found_or_not = true
          similar_words_in_a_dict << _1
        end
      end
    # end of each sheet in a dict
    end

    unless similar_words_in_a_dict.empty?
      pp_dict(dict)
      require 'ls_table'
      LsTable.ls(similar_words_in_a_dict) do |e|
        puts blue(e)
      end
      puts
    end
  end
  return found_or_not
end


def help
  word_count(p: false)
  puts <<-HELP
cr: Cryptic Resolver v#{CR_GEM_VERSION} (#{$TwoLibWordCount} words: Default lib/#{$DefaultLibWordCount} && Extra lib/#{$ExtraLibWordCount})

Usage:

Query:
  cr <keyword>   Search the keyword
  cr emacs       => Edit macros: A feature-rich editor

Options:
  -c             Print word count
  -s pattern     Search words matched with pattern
  -h             Print this help

Dictionaries:
  -l                      List local dicts and official dicts
  -a <https://repo[.git]> Add a new dict
  -a <user/repo>          Add a new dict from Github
  -a <dict_name>          Add an official dict, use -l to see
  -u                      Update all dicts in Default library
  -d <dict_name>          Delete a dict

HELP

  add_default_dicts_if_none_exists

end


def print_version
  puts "cr: Cryptic Resolver version #{CR_GEM_VERSION} in Ruby "
end


#
# 1. List Default library's dicts
# 2. List Extra   library's dicts
# 3. List official dicts
#
def list_dicts
  Dir.chdir DEFAULT_LIB_PATH do
    puts blue("=> Default library: #{DEFAULT_LIB_PATH}")
    Dir.children(DEFAULT_LIB_PATH).each_with_index do |dict,i|
      puts "#{blue(i+1)}. #{bold(green(dict))}"
    end
  end

  if EXTRA_LIB_PATH
    puts
    Dir.chdir EXTRA_LIB_PATH do
      puts blue("=> Extra library: #{EXTRA_LIB_PATH}")
      Dir.children(EXTRA_LIB_PATH).each_with_index do |dict,i|
        puts "#{blue(i+1)}. #{bold(green(dict))}"
      end
    end
  end

  puts
  puts blue("=> Official dicts: (Add it by 'cr -a xxx')")
  puts CrypticResolver::RECOMMENDED_DICTS

end


# Two libraries word count (Default library + Extra library)
$TwoLibWordCount = 0
# Default library word count
$DefaultLibWordCount = 0
#  Extra  library word count
$ExtraLibWordCount   = 0

def count_dict_words(library, dict)

  dict_dir = library + "/#{dict}"

  wc = 0

  Dir.children(dict_dir).each do |entry|
    next unless entry.end_with?('.toml')
    sheet_content = load_sheet(library, dict, entry.delete_suffix('.toml'))
    count = sheet_content.keys.count

    wc = wc + count
  end
  return wc
end


def word_count(p:)
  # Always check before Dir.children (this method creates dir if not exists)
  is_there_any_dict?

  default_lib = Dir.children(DEFAULT_LIB_PATH)

  # Count default library
  unless default_lib.empty?
    puts(bold(green("Default library: "))) if p
    default_lib.each do |s|
      wc = count_dict_words(DEFAULT_LIB_PATH,s)
      $DefaultLibWordCount += wc
      # With color, ljust not works, so we disable color
      puts("  #{s.ljust(17)}: #{wc}") if p
    end
  end


  if EXTRA_LIB_PATH
    extra_lib = Dir.children(EXTRA_LIB_PATH)
    extra_lib.reject! do |f|
      File.file? f
    end
    # Count extra library
    unless extra_lib.empty?
      wc = 0
      puts(bold(blue("\nExtra library:"))) if p
      extra_lib.each do |s|
        wc = count_dict_words(EXTRA_LIB_PATH,s)
        $ExtraLibWordCount += wc
        puts("  #{s.ljust(17)}: #{wc}") if p
      end
    end
  end
  $TwoLibWordCount = $DefaultLibWordCount + $ExtraLibWordCount

  if p
  puts
  puts "#{$DefaultLibWordCount.to_s.rjust(4)} words in Default library"
  puts "#{$ExtraLibWordCount.to_s.rjust(4)  } words in  Extra  library"
  puts "#{$TwoLibWordCount.to_s.rjust(4)    } words altogether"
  end
end


####################
# main: CLI Handling
####################
arg = ARGV.shift

case arg
when nil    then help
when '-v'   then print_version
when '-h'   then help
when '-l'   then list_dicts
when '-c'   then word_count(p: true)
when '-u'   then update_dicts
when '-s'   then search_word ARGV.shift
when '-a'   then add_dict ARGV.shift
when '-d'   then del_dict ARGV.shift
when '--help'
  help
else
  resolve_word arg
end
