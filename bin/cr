#!/usr/bin/env ruby
# coding: utf-8
#  ---------------------------------------------------
#  File          : cr.rb
#  Authors       : ccmywish <ccmywish@qq.com>
#  Created on    : <2021-7-8>
#  Last modified : <2022-2-9>
#
#  This file is used to explain a CRyptic command
#  or an acronym's real meaning in computer world or 
#  orther fileds.  
#
#  ---------------------------------------------------

require 'tomlrb'
require 'fileutils'

CRYPTIC_RESOLVER_HOME = File.expand_path("~/.cryptic-resolver")
CRYPTIC_DEFAULT_DICTS = {
  computer: "https://github.com/cryptic-resolver/cryptic_computer.git",
  common:   "https://github.com/cryptic-resolver/cryptic_common.git",
  science:  "https://github.com/cryptic-resolver/cryptic_science.git",
  economy:  "https://github.com/cryptic-resolver/cryptic_economy.git",
  medicine: "https://github.com/cryptic-resolver/cryptic_medicine.git"
}

CRYPTIC_VERSION = "4.3"


####################
# helper: for color
####################

def bold(str)       "\e[1m#{str}\e[0m" end
def underline(str)  "\e[4m#{str}\e[0m" end
def red(str)        "\e[31m#{str}\e[0m" end
def green(str)      "\e[32m#{str}\e[0m" end
def yellow(str)     "\e[33m#{str}\e[0m" end
def blue(str)       "\e[34m#{str}\e[0m" end
def purple(str)     "\e[35m#{str}\e[0m" end
def cyan(str)       "\e[36m#{str}\e[0m" end


####################
# core: logic
####################

def is_there_any_dict?
  unless Dir.exist? CRYPTIC_RESOLVER_HOME
    Dir.mkdir CRYPTIC_RESOLVER_HOME
  end

  !Dir.empty? CRYPTIC_RESOLVER_HOME 
end


def add_default_dicts_if_none_exists
  unless is_there_any_dict?
    puts "cr: Adding default dictionaries..."
    CRYPTIC_DEFAULT_DICTS.each do |key, dict|
      puts "cr: Pulling cryptic_#{key}..."
      `git -C #{CRYPTIC_RESOLVER_HOME} clone #{dict} -q`
    end
    puts "cr: Add done"
  end
end


def update_dicts()
  add_default_dicts_if_none_exists

  puts "cr: Updating all dictionaries..."
  Dir.chdir CRYPTIC_RESOLVER_HOME do 
    Dir.children(CRYPTIC_RESOLVER_HOME).each do |dict|
      puts "cr: Wait to update #{dict}..."
      `git -C ./#{dict} pull -q`
    end
  end
  puts "cr: Update done"
end


def add_dict(repo)
  if repo.nil? 
    puts bold(red("cr: Need an argument!"))
    exit -1
  end
  puts "cr: Adding new dictionary..."
  `git -C #{CRYPTIC_RESOLVER_HOME} clone #{repo} -q`
  puts "cr: Add new dictionary done"
end


def del_dict(repo)
  if repo.nil? 
    puts bold(red("cr: Need an argument!"))
    exit -1
  end
  Dir.chdir CRYPTIC_RESOLVER_HOME do 
    begin 
      # Dir.rmdir repo        # Can't rm a filled dir
      # FileUtils.rmdir repo  # Can't rm a filled dir
      FileUtils.rm_rf repo
      puts "cr: Delete dictionary #{bold(green(repo))} done"
    rescue Exception => e
      puts bold(red("cr: #{e}"))
      list_dictionaries
    end
  end
end


def load_sheet(dict, sheet_name)
  file = CRYPTIC_RESOLVER_HOME + "/#{dict}/#{sheet_name}.toml" 
  
  if File.exist? file
    return Tomlrb.load_file file # gem 'tomlrb'
    # return TOML.load_file file # gem 'toml'
  else
    nil
  end
end


#
# Pretty print the info of the given word
#
# A info looks like this
#   emacs = {
#     disp = "Emacs" 
#     desc = "edit macros"
#     full = "a feature-rich editor"
#     see  = ["Vim"]
#   }
#
# @param info [Hash] the information of the given word (mapped to a keyword in TOML) 
#
def pp_info(info)
  disp = info['disp'] || red("No name!")  # keyword `or` is invalid here in Ruby
  puts "\n  #{disp}: #{info['desc']}"

  if full = info['full']
    print "\n  ",full,"\n"
  end
  
  if see_also = info['see']
    print "\n", purple("SEE ALSO ")
    see_also.each {|x| print underline(x),' '}
    puts
  end 
  puts
end

# Print default cryptic_ dictionaries
def pp_dict(dict)
    puts green("From: #{dict}")
end


#
# Used for synonym jump
# Because we absolutely jump to a must-have word
# So we can directly lookup to it
#
# Notice that, we must jump to a specific word definition
# So in the toml file, you must specify the precise word. 
# If it has multiple meanings, for example
# 
#   [blah]
#   same = "XDG"  # this is wrong
#
#   [blah]
#   same = "XDG.Download" # this is right
#
def directly_lookup(dict,sheet_name,word)
  piece = load_sheet(dict,sheet_name.downcase) 

  words =  word.split('.')  # [XDG Download]
  word = words.shift        # XDG [Download]
  explain = words.first
  if explain.nil?
    info = piece[word]
  else
    info = piece[word][explain]
  end

  # Warn user this is the toml maintainer's fault
  if info.nil?
    puts red("WARN: Synonym jumps to a wrong place at `#{word}` 
      Please consider fixing this in `#{sheet_name.downcase}.toml` of the dictionary `#{dict}`")
    exit
  end

  pp_info(info)
  return true # always true
end


#
# Lookup the given word in a sheet (a toml file) and also print.
# The core idea is that:
#
# 1. if the word is `same` with another synonym, it will directly jump to 
#   a word in this dictionary, but maybe a different sheet.
#
# 2. load the toml file and check the given word
#   2.1 with no category specifier
#       [abcd]
#   2.2 with category specifier
#       [abcd.type]
#
def lookup(dict, file, word)
  piece = load_sheet(dict, file) 
  return false if piece.nil?

  info = piece[word]
  return false if info.nil?

  # Warn if the info is empty. For example:
  #   emacs = { }
  if info.size == 0
    puts red("WARN: Lack of everything of the given word 
      Please consider fixing this in the dict `#{dict}`")
    exit 
  end

  # If it's a synonym for anther word,
  # we should lookup into this dict again, but maybe with a different file
  if same = info['same']
    pp_dict(dict)
    
    puts blue(bold(word)) + ' redirects to ' + blue(bold(same))
    
    if same.chr.downcase == file  # no need to load dictionary again
      # Explicitly convert it to downcase.
      # In case the dictionary maintainer redirects to an uppercase word by mistake.
      same = same.downcase
      info = piece[same]
      if info.nil?
        puts red("WARN: Synonym jumps to the wrong place `#{same}`,
          Please consider fixing this in `#{file.downcase}.toml` of the dictionary `#{dict}`")
        exit
        return false
      else
        pp_info(info)
        return true
      end
    else
      return directly_lookup(dict, same.chr, same)
    end
  end

  # Single meaning with no category specifier
  # We call this meaning as type 1
  type_1_exist_flag = false
  if info.has_key?('desc')
    pp_dict(dict)
    pp_info(info)
    type_1_exist_flag = true
  end

  # Meanings with category specifier
  # We call this meaning as type 2
  categories = info.keys - ["disp", "desc", "full", "same", "see"]

  if !categories.empty?
    if type_1_exist_flag
      print  blue(bold("OR")),"\n"
    else
      pp_dict(dict)
    end

    categories.each do |meaning|
      pp_info(piece[word][meaning])
      # last meaning doesn't show this separate line
      print  blue(bold("OR")),"\n" unless categories.last == meaning
    end
    return true
  elsif type_1_exist_flag
    return true
  else
    return false
  end
end


#
# The main procedure of `cr`
#   1. Search the default's first dict first
#   2. Search the rest dictionaries in the cryptic dictionaries default dir
# 
# The `search` is done via the `lookup` function. It will print
# the info while finding. If `lookup` always return false then
# means lacking of this word in our dictionaries. So a welcomed
# contribution is prinetd on the screen.
#
def solve_word(word)
  
  add_default_dicts_if_none_exists

  word = word.downcase # downcase! would lead to frozen error in Ruby 2.7.2
  # The index is the toml file we'll look into
  index = word.chr
  case index 
  when '0'..'9' 
    index = '0123456789'
  end
  
  # Default's first should be 1st to consider
  first_dict = "cryptic_" + CRYPTIC_DEFAULT_DICTS.keys[0].to_s # When Ruby3, We can use DICTS.key(0)

  # cache lookup results
  results = []
  results << lookup(first_dict,index,word)
  # return if result == true # We should consider all dicts

  # Then else
  rest = Dir.children(CRYPTIC_RESOLVER_HOME)
  rest.delete first_dict
  rest.each do |dict|
    results << lookup(dict,index,word)
    # continue if result == false # We should consider all dicts
  end

  unless results.include? true
    puts <<-NotFound
cr: Not found anything.

You may use `cr -u` to update all dictionaries.
Or you could contribute to:

  1. computer:   #{CRYPTIC_DEFAULT_DICTS[:computer]}
  2. common:     #{CRYPTIC_DEFAULT_DICTS[:common]}
  3. science:    #{CRYPTIC_DEFAULT_DICTS[:science]}
  4. economy:    #{CRYPTIC_DEFAULT_DICTS[:economy]}
  5. medicine:   #{CRYPTIC_DEFAULT_DICTS[:medicine]}

NotFound

  else
    return
  end
  
end


def help
  puts <<-HELP
cr: Cryptic Resolver version #{CRYPTIC_VERSION} in Ruby 

usage:
  cr -v                  => Print version
  cr -h                  => Print this help
  cr -l                  => List local dictionaries
  cr -u                  => Update all dictionaries
  cr -a xx.com/repo.git  => Add a new dictionary
  cr -d cryptic_xx       => Delete a dictionary
  cr emacs               => Edit macros: a feature-rich editor

HELP
end


def print_version
  puts "cr: Cryptic Resolver version #{CRYPTIC_VERSION} in Ruby "
end


def list_dictionaries
  Dir.chdir CRYPTIC_RESOLVER_HOME do 
    Dir.children(CRYPTIC_RESOLVER_HOME).each_with_index do |dict,i|
      puts "#{blue(i+1)}. #{bold(green(dict))}"
    end
  end
end


####################
# main: CLI Handling
####################
arg = ARGV.shift

case arg
when nil    then (help || add_default_dicts_if_none_exists)
when '-v'   then print_version
when '-h'   then help
when '-l'   then list_dictionaries
when '-u'   then update_dicts   
when '-a'   then add_dict ARGV.shift
when '-d'   then del_dict ARGV.shift   
else
  solve_word arg
end
 